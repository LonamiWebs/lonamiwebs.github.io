<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=description content="Official Lonami's website"><meta name=viewport content="width=device-width, initial-scale=1.0, user-scalable=yes"><title> Writing our own Cheat Engine: Multilevel pointers | Lonami's Blog </title><link rel=stylesheet href=/style.css><body><article><nav class=sections><ul class=left><li><a href=/>lonami'sÂ site</a><li><a href=/blog class=selected>blog</a><li><a href=/golb>golb</a></ul><div class=right><a href=https://github.com/LonamiWebs><img src=/img/github.svg alt=github></a><a href=/blog/atom.xml><img src=/img/rss.svg alt=rss></a></div></nav><main><h1 class=title>Writing our own Cheat Engine: Multilevel pointers</h1><div class=time><p>2021-05-15</div><p>This is part 8 on the <em>Writing our own Cheat Engine</em> series:<ul><li><a href=/blog/woce-1>Part 1: Introduction</a> (start here if you're new to the series!)<li><a href=/blog/woce-2>Part 2: Exact Value scanning</a><li><a href=/blog/woce-3>Part 3: Unknown initial value</a><li><a href=/blog/woce-4>Part 4: Floating points</a><li><a href=/blog/woce-5>Part 5: Code finder</a><li><a href=/blog/woce-6>Part 6: Pointers</a><li><a href=/blog/woce-7>Part 7: Code Injection</a><li>Part 8: Multilevel pointers</ul><p>In part 7 we...<p>In this post, we...<h2 id=multilevel-pointers>Multilevel pointers</h2><details open><summary>Cheat Engine Tutorial: Step 8</summary> <blockquote><p>This step will explain how to use multi-level pointers.<p>In step 6 you had a simple level-1 pointer, with the first address found already being the real base address. This step however is a level-4 pointer. It has a pointer to a pointer to a pointer to a pointer to a pointer to the health.<p>You basicly do the same as in step 6. Find out what accesses the value, look at the instruction and what probably is the base pointer value, and what is the offset, and already fill that in or write it down. But in this case the address you'll find will also be a pointer. You just have to find out the pointer to that pointer exactly the same way as you did with the value. Find out what accesses that address you found, look at the assembler instruction, note the probable instruction and offset, and use that, and continue till you can't get any further (usually when the base address is a static address, shown up as green).<p>Click Change Value to let the tutorial access the health. If you think you've found the pointer path click Change Register. The pointers and value will then change and you'll have 3 seconds to freeze the address to 5000.<p>Extra: This problem can also be solved using a auto assembler script, or using the pointer scanner.<p>Extra2: In some situations it is recommended to change ce's codefinder settings to Access violations when encountering instructions like mov eax,[eax] since debugregisters show it AFTER it was changed, making it hard to find out the the value of the pointer.<p>Extra3: If you're still reading. You might notice that when looking at the assembler instructions that the pointer is being read and filled out in the same codeblock (same routine, if you know assembler, look up till the start of the routine). This doesn't always happen, but can be really useful in finding a pointer when debugging is troublesome.</blockquote></details><h2 id=pointers-pointing-points>Pointers pointing points</h2><p>If you say "pointer" enough, you'll end up having <a href=https://en.wikipedia.org/wiki/Semantic_satiation>semantic satiation</a>. My goal by the end of this post is that you actually get to experience that phenomenon. Anyway, no real program would actually have pointers pointing to pointers which themselves point to a different point (you guessed it, another pointer pointing to yet another pointer), right? That would be silly. Why would I have a value behind, say, 5 references? I'm not writing Rust code like <code>&&&&&value</code>.<p>But I am sure you are much more likely to be doing something like <code>game.world.areas[i].players[j].regen()</code>. And there's a lot of references there:<pre><code> game.world.areas[i].players[j].regen()
^    ^           ^^^        ^^^      ^^
|    |            |          |        \called by &mut ref
|    |            |           \taking by &mut ref
|    |             \taking by &mut ref
|     \accessing by &mut ref
 \this game is actually in a `Box` (so you're accessing it behind other ref)
</code></pre><p>Each of those is a different structure, with many fields each (for example, the areas also contain enemies and items dropped in different vectors. So a pointer does not necessarily point directly to the desired field! To complicate things further, the same reference to one thing may be stored in multiple locations, making it possible to find your goal address through many different paths.<pre><code class=language-rust data-lang=rust>#[repr(C)] // &LT- used for clarity to get precise offsets
struct Area {
    /* offset 00 */ pub monsters: Vec&LTMonster>,
    /* offset 24 */ pub items: Vec&LTItem>,
    /* offset 48 */ pub kill_goal: u32,
    /* offset 52 */ pub players: Vec&LTPlayer>,
}
</code></pre><p>If you have a reference to some <code>&Area</code> but access the <code>players</code> field, you actually need to read from <code>[addrof area + 52]</code>. This is why the tutorial step suggests to "look at the instruction", because it very likely encodes the offset somewhere (if not directly, nearby). Looking at instructions to determine offsets works because normally people want their games to be fast, so they make good use of the available CPU instructions. Obfuscating hot code could slow a game way too much (but it may still be done to some degree!).<p>The tutorial suggests to complete this step in the same way we did back in step 6. Add a watchpoint, find out what code is accessing this address, look around the disassembly, and write down your findings. Although this technique definitely is a valid way to approach the problem, it is quite tedious and error-prone. It would be hard to fully automate this, because who knows what shenanigans the code could be doing to calculate the right pointer and offset!<p>It's also pretty intrusive, because it requires us to attach ourselves as the debugger of the victim program. I hardly have any experience writing debuggers, leave alone writing them in a way that makes them hard to detect! I'm sure it's a very interesting topic, but it's not the current topic at hand, so we'll leave it be. Furthermore, we've already gone that route, so it would be silly to repeat that here, just a longer version of it.<p>You may have noticed the "extra" information the tutorial step provides:<blockquote><p>Extra: This problem can also be solved using a auto assembler script, or using the pointer scanner.</blockquote><p>We've already done the "auto assembler script" part before (in part 7). I'm not sure how you would approach this problem with that technique. Maybe one could dig until the base pointer, and replace whatever read is happening there with a hardcoded value so that the game thinks that's what it actually read? I'm not sure if it would be possible to solve with injected code without following the entire pointer chain. But anyway, we're not doing that, no manual work will happen on this one. No, we're interested in the <span class=rainbow>pointer scanner</span><sup class=footnote-reference><a href=#1>1</a></sup>.<h2 id=pointer-maps>Pointer maps</h2><p>Once you find a value in Cheat Engine, you have the option to "Generate pointermap". This will prompt you to select a file where the generated pointermap will be stored, in <code>.scandata</code> format (along with its <code>.addresslist</code>). If you're scanning a lot of memory, you will get to see a progress window (otherwise, it will be pretty much instant), along with some statistics:<ul><li>Unique pointervalues in target.<li>Scan duration.<li>Paths evaluated.<li>Paths / seconds.<li>Static and dynamic queue sizes.<li>Results found.<li>Time spent writing.<li>Lowest known path.</ul><p>My guess for "unique pointervalues" is the set of pointers found so far, and the queues may be used by the way the scan is done. The rest of information is pretty much self-explanatory (lowest known path probably is the shortest "pointer path" found so far). When I'm talking about "pointer paths", I'm referring to a known, static base address that won't change, with a list of offsets that, when followed, arrive at some desired value in memory (for example, your character's health). For this step, the solution found with Cheat Engine is a good example:<pre><code class=language-rusty data-lang=rusty>let offsets = [10, 18, 0, 18]; // list of offsets
let mut addr = EXE_BASE_ADDR + 0x00306B00; // current addr (initialized to base addr)

// follow the path:
// addr_at("Tutorial-x86_64.exe"+00306B00) -> 0165F260
// addr_at(10+0165F260) -> 01690000
// addr_at(18+01690000) -> 01677790
// addr_at( 0+01677790) -> 01601A80
//         18+01601A80  -> 01601A98
for offset in offsets {
    addr = process.read_addr_at(addr);
    addr += offset;
}

let value = process.read_desired_value_at(addr);
</code></pre><p>After generating the pointermap, the idea is to force the game to change the pointer path (for example, by closing and re-opening the game again) and find your target value once again. For the tutorial, we can just change the pointer. After we find the value again, we do a "Pointer scan for this address". The "Pointerscanner options" has a checkbox to "Compare results with other saved pointermap(s)". Running this seems to generate a second pointermap, and after some magic, both are compared and the one true pointer path is found.<p>There's a bunch of files generated:<ul><li><code>.scandata</code> is a bunch of binary data that I have no idea what could contain.<li><code>.scandata.addresslist</code> seems to contain <code>ADDRESS=DESCRIPTION</code>, one per line, of the addresses you had "saved" when the first pointermap was made. This seems to be used when performing the pointer scan and comparing results (so that you can choose the address you want to compare it to).<li><code>.PTR</code> is 1201 bytes (such an strange size) and seems to contain a list of the modules loaded by the program<li><code>.PTR.results.#</code>, where <code>#</code> is a number between 0 and 8, are mostly empty files (except for 4 which is 14 bytes).</ul><p>Now, there's this one option under "advanced" known as "Compress pointerscan file". The long description reads (emphasis mine):<blockquote><p>Compresses the generated .PTR files <em>slightly</em>, so they take less space on the disk and less time writing to disk. Most of the time the bottleneck of a pointerscan is disk writing, so it is recommended to use this option.</blockquote><p>Slightly, huh. Well, for the tutorial, which is using (according to the task manager) 2'364 K, running the scan with the compression disabled generates roughly <em>5 gigabytes</em> across the nine <code>.PTR.results</code>. That'sâ¦ not too shabby for a "slight" compression.<p>Let's guess what those files are storing. The screen with the results does say it found uh, well you know, the usual, 122'808'639 pointer paths. This is the result of scanning for an address. That's (very) roughly 40 bytes per path, and assuming 8 bytes for each address/offset, equates to 5 hops. I guess the math kind of checks out?<p>On the other hand, "generate pointermap" just spits out the <code>.scandata</code> at roughly 60KB. So these two options are definitely doing something very, very different. And I have no idea what either of these are doing. Let's dive into Cheat Engine's "advanced options" for the pointer scan to try and gain some insight. I will be listing all the settings available in the scan form and adding a bit on whether I think they're useful to us or not.<h2 id=scan-options>Scan options</h2><p>The <em>Pointerscanner scanoptions</em> window has plenty of options that are extremely valuable to gain insight of what's going on behind the scenes without having to dig into the code. At the very top we have three modes:<ul><li>Scan for address<li>Scan for addresses with value<li>Generate pointermap</ul><p>The third option is what we use during the first step, and the first option for the second step.<p>When using either the first or second mode, you can also check <em>Use saved pointermap</em> which you can use if you have created a pointermap on a system that runs the game, but you wish to do the scan on another system (or multiple systems).<p>With the first or second mode, you can also <em>Compare results with other saved pointermap(s)</em> which, when ticked, lets you add other pointermaps which will be used to verify that the pointers it finds are correct. You do have to fill in the correct address for each pointermap provided, and one should expect at least the size of the game itself in memory for every pointermap used. We know this step is key, but we don't know how that comparison could be possibly done.<p>The checkbox <em>Include system modules</em> I presume also scans in system modules and not just game's own modules, which is useful if you suspect the value lives elsewhere. Not helpful for us right now, but good to know this is a possibility.<p>Apparently, Cheat Engine can improve pointerscan with gathered heap data. The heap is used to figure out the offset sizes, instead of blindly guessing them. This should greatly improve speed and a lot less useless results and give perfect pointers, but if the game allocates gigantic chunks of heap memory, and then divides it up itself, this will give wrong results. If you only allow static and heap addresses in the path, when the address searched isn't a heap address, the scan will return 0 results. I do not really know how Cheat Engine gathers heap data here to improve the pointerscan, but since this mode is unchecked by default, we should be fine without it.<p>By default, the pointer path may only be inside the region 0000000000000000-7FFFFFFFFFFFFFFF. There's a fancier option to limit scan to specified region file, which presumably enables a more complex, discontinuous region. Or you can filter pointers so that they end with specific offsets. Or you can indicate that the base address must be in specific range, which will only mark the given range as valid base address (this reduces the number of results, and internally makes use of the "Only find paths with a static address" feature by marking the provided range as static only, so it must be enabled).<p>Pointers with read-only nodes are excluded by default, so the pointerscan will throw away memory that is readonly. When it looks for paths, it won't encounter paths that pass through read only memory blocks. This is often faster and yields less useless results, but if the game decides to mark a pointer as readonly Cheat Engine won't find it.<p>Only paths with a static address are "found". The pointerscan will only store a path when it starts with a static address (or easily looked up address). It may miss pointers that are accessed by special paths like thread local storage (but even then they'd be useless for Cheat Engine as they will change). When it's disabled, it finds every single pointer path. Now, this bit is interesting, because the checkbox talks about "find", but the description talks about "store", so we can guess there's no trick to only "finding" correct ones. It's going to find a lot of things, and many of them will be discarded. It also mentions thread-local storage and how we probably shouldn't worry about it.<p>Cheat Engine won't stop traversing a path when a static has been found by default. When the pointerscanner goes through the list of pointervalues with a specific value, this will stop exploring other paths as soon as it encounters a static pointer to that value. By enabling this option, some valid results could be missed. This talks about "pointervalues with a specific value", which is a bit too obscure for me to try and make any sense out of it.<p>Addresses must be 32-bit alligned. Only pointers that are stored in an address dividable by 4 are looked at. When disabled, it won't bother. It enables fast scans, but "on some horrible designed games that you shouldn't even play it won't find the paths". Values in memory are often aligned, so reducing the search space by 75% is a no-brainer.<p>Cheat Engine can optionally verify that the first element of pointerstruct must point to module (e.g vtable). Object oriented programming languages tend to implement classobjects by having a pointer in the first element to something that describes the class. With this option enabled, Cheat Engine will check if it's a classobject by checking that rule. If not, it won't see it as a pointer. It should yield a tremendous speed increase and almost perfect pointers, but it doesn't work with runtime generated classes (Java, .NET). Optionally, it can also accept non-module addresses. I have no idea how this is achieved, but since it's disabled by default, we can forget about it.<p>By default, no looping pointers are allowed. This will filter out pointerpaths that ended up in a loop (for example, base->p1->p2->p3->p1->p4 since you could just as well do base->p1->p4 then, so throw this one away (base->p1->p4 will be found another way)). This gives less results so less diskspace used, but slightly slows down the scan as it needs to check for loops every single iteration. The thought of how much data the 5GB scan would generate without this option makes me shiver.<p>Cheat Engine will allow stack addresses of the first thread(s) to be handled as static, which allows the stack of threads to be seen as static addresses by the pointerscan. The main thread is always a sure bet that it's the first one in the list. And often the second thread created is pretty stable as well. With more there's a bigger chance they get created and destroyed randomly. When a program enters a function and exits it, the stack pointer decreases and increases, and the data there gets written to. The farther the game is inside function calls, the more static the older data will be. With max stack offset you can set the max size that can be deemed as static enough (the max stackoffset to be deemed static enough is 4096 by default). It finds paths otherwise never found, but since there are more results, there's more diskspace.<p>Cheat Engine by default will look at the stacks of two threads, from oldest to newest. It indicates "he total number of threads that should be allowed to be used as a stack lookup. Thread 1 is usually the main thread of the game, but if that one spawns another thread for game related events, you might want to have that secondary thread as well. More threads is not recommend as they may get created and destroyed on the fly, and are therefore useless as a lookup base, but it depends on the game".<p>Unfortunately, this option is enabled by default, so it seems pretty important, and we might need to put some work into figuring out how "stacks" are found. However, this would mean that some "base" object (like a <code>Game</code> instance) is passed down by reference hundreds of calls, which seems pretty annoying just to have access to something that effectively acts like a global, so hopefully games don't make use of this.<p>This can be taken a step further, and consider stack addresses as ONLY static address, if you wish to only find pointer paths with a stack address.It must be combined with "Only find paths with a static address" (default on) else this option will have no effect. You'll only get paths from the stack, but you don't get get paths from random DLL's or the executable.<p>The pointerscan file is by default compressed. Cheat Engine Compresses the generated .PTR files slightly so they take less space on the disk and less time writing to disk. Most of the time the bottleneck of a pointerscan is disk writing, so it is recommended to use this option (which was not available in older versions).<p>Only positive offsets are scanned by default, but Cheat Engine may optionally scan for negative offsets as well (although it can not be used in combination with compressed pointerscan files; this seems to hint that the compression assumes only positive values).<p>On my machine, 9 threads are scanning by default with a maximum offset value of 4095 and a maximum level (depth) of 7. The maximum different offsets per node are 3. When the pointerscan looks through the list of pointers with a specific value, it goes through every single pointer that has that value. Every time increasing the offset slightly. With this feature enabled the pointerscan will only check the first few pointers with that value. This is extremely fast, and the results have the lowest pointer paths possible, but you'll miss a lot of pointers that might be valid too. I think this description is key, as it clearly says what the pointerscan does and maybe even how it works (although it sounds a bit inefficient, so Cheat Engine probably uses other tricks).<p>Cheat Engine clearly knows this process is expensive, so it optionally allow scanners to connect at runtime. This opens a port that other systems running the pointerscanner can connect to and help out with the scan. Or it can connect to pointerscan node, which will send a broadcast message on the local network which will tell pointer scanner systems to join this scan if they are set to auto join (or "Setup specific IP's to notify" to notify systems of this scan that are outside of the local network).<p>And that's all! In summary:<ul><li>Assume addresses are 32-bit aligned (maybe even 64-bit).<li>Discard paths that don't end in a static address (bonus points if the top of the stack for the firsts two threads are also considered).<li>Ignore read-only memory.<li>Limit the number of offsets per pointer to something small like 3, and give up after reaching a depth greater than 7.<li>Limit the offset range to <code>0..4096</code>.<li>Use multiple threads.</ul><h2 id=single-threaded-naive-approach>Single-threaded naive approach</h2><p>After playing around a bit more with Cheat Engine's scans, I realized the 14 bytes of the <code>.PTR.results.4</code> is because the process literally finds a single path which it places there. Running the process with compression and no previous scan to compare it to spits out roughly 750MB (so the compression does go from 5GB to 750MB, that's a lot more reasonable).<p>In any case, we're with the <code>.scandata</code> now. I really do wonder what could it possibly contain? I really doubt it's the pointer paths found, because then it would be huge. Perhaps it contains the memory regions? That would make some sense, since the sibling <code>.addresslist</code> <em>is</em> a list of all the loaded modules. Maybe the <code>.scandata</code> contains the memory regions for all of those loaded modules.<hr><p>(PW=525927) - SHOW OSIRI RAINBOW WHEN DONE<h2 id=finale>Finale</h2><p>This post...<h3 id=footnotes>Footnotes</h3><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>I spent a good chunk of time figuring out how to get this effect on the text (and borrowing code from several sites), but I'm extremely satisfied with the result. You do need a "modern" browser to see what I mean, though.</div></main><footer><div><p>Share your thoughts, or simply come hang with me <a href=https://t.me/LonamiWebs><img src=/img/telegram.svg alt=Telegram></a> <a href=mailto:totufals@hotmail.com><img src=/img/mail.svg alt=Mail></a></div></footer></article><p class=abyss>Gaze into the abyssâ¦ Oh hi there!