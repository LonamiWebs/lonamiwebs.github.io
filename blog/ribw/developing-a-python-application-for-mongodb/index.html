<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content="Official Lonami's website"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"><title>Developing a Python application for MongoDB | Lonami's Blog</title><link rel="stylesheet" type="text/css" href="/style.css"> 
</head><body><nav><ul><li><a  href="/">lonami's&nbsp;site</a></li><li><a class=selected href="/blog">blog</a></li><li><a  href="/golb">golb</a></li></ul><div><a href="https://github.com/LonamiWebs"><img src="/img/github.svg" alt="github"></a><a href="/blog/atom.xml"><img src="/img/rss.svg" alt="rss"></a></div></nav><main><article><h1 class="title">Developing a Python application for MongoDB</h1><div class="time"><p>2020-03-25</p><p>last updated 2020-04-16</p></div><p>This is the third and last post in the MongoDB series, where we will develop a Python application to process and store OpenData inside Mongo.</p><p>Other posts in this series:</p><ul><li><a href="/blog/ribw/mongodb-an-introduction/">MongoDB: an Introduction</a></li><li><a href="/blog/ribw/mongodb-basic-operations-and-architecture/">MongoDB: Basic Operations and Architecture</a></li><li><a href="/blog/ribw/developing-a-python-application-for-mongodb/">Developing a Python application for MongoDB</a> (this post)</li></ul><p>This post is co-authored wih a Classmate.</p><hr><h2 id="what-are-we-making"><a href="#what-are-we-making">What are we making?</a></h2><p>We are going to develop a web application that renders a map, in this case, the town of Cáceres, with which users can interact. When the user clicks somewhere on the map, the selected location will be sent to the server to process. This server will perform geospatial queries to Mongo and once the results are ready, the information is presented back at the webpage.</p><p>The data used for the application comes from <a href="https://opendata.caceres.es/">Cáceres’ OpenData</a>, and our goal is that users will be able to find information about certain areas in a quick and intuitive way, such as precise coordinates, noise level, and such.</p><h2 id="what-are-we-using"><a href="#what-are-we-using">What are we using?</a></h2><p>The web application will be using <a href="https://python.org/">Python</a> for the backend, <a href="https://svelte.dev/">Svelte</a> for the frontend, and <a href="https://www.mongodb.com/">Mongo</a> as our storage database and processing center.</p><ul><li><strong>Why Python?</strong> It’s a comfortable language to write and to read, and has a great ecosystem with <a href="https://pypi.org/">plenty of libraries</a>.</li><li><strong>Why Svelte?</strong> Svelte is the New Thing<strong>™</strong> in the world of component frameworks for JavaScript. It is similar to React or Vue, but compiled and with a lot less boilerplate. Check out their <a href="https://svelte.dev/blog/svelte-3-rethinking-reactivity">Svelte post</a> to learn more.</li><li><strong>Why Mongo?</strong> We believe NoSQL is the right approach for doing the kind of processing and storage that we expect, and it’s <a href="https://docs.mongodb.com/">very easy to use</a>. In addition, we will be making Geospatial Queries which <a href="https://docs.mongodb.com/manual/geospatial-queries/">Mongo supports</a>.</li></ul><p>Why didn’t we choose to make a smaller project, you may ask? You will be shocked to hear that we do not have an answer for that!</p><p>Note that we will not be embedding <strong>all</strong> the code of the project in this post, or it would be too long! We will include only the relevant snippets needed to understand the core ideas of the project, and not the unnecessary parts of it (for example, parsing configuration files to easily change the port where the server runs is not included).</p><h2 id="python-dependencies"><a href="#python-dependencies">Python dependencies</a></h2><p>Because we will program it in Python, you need Python installed. You can install it using a package manager of your choice or heading over to the <a href="https://www.python.org/downloads/">Python downloads section</a>, but if you’re on Linux, chances are you have it installed already.</p><p>Once Python 3.7 or above is installed, install <a href="https://motor.readthedocs.io/en/stable/"><code>motor</code> (Asynchronous Python driver for MongoDB)</a> and the <a href="https://docs.aiohttp.org/en/stable/web.html"><code>aiohttp</code> server</a> through <code>pip</code>:</p><pre>pip install aiohttp motor
</pre><p>Make sure that Mongo is running in the background (this has been described in previous posts), and we should be able to get to work.</p><h2 id="web-dependencies"><a href="#web-dependencies">Web dependencies</a></h2><p>To work with Svelte and its dependencies, we will need <code>[npm](https://www.npmjs.com/)</code> which comes with <a href="https://nodejs.org/en/">NodeJS</a>, so go and <a href="https://nodejs.org/en/download/">install Node from their site</a>. The download will be different depending on your operating system.</p><p>Following <a href="https://svelte.dev/blog/the-easiest-way-to-get-started">the easiest way to get started with Svelte</a>, we will put our project in a <code>client/</code> folder (because this is what the clients see, the frontend). Feel free to tinker a bit with the configuration files to change the name and such, although this isn’t relevant for the rest of the post.</p><h2 id="finding-the-data"><a href="#finding-the-data">Finding the data</a></h2><p>We are going to work with the JSON files provided by <a href="http://opendata.caceres.es/">OpenData Cáceres</a>. In particular, we want information about the noise, census, vias and trees. To save you the time from <a href="http://opendata.caceres.es/dataset">searching each of these</a>, we will automate the download with code.</p><p>If you want to save the data offline or just know what data we’ll be using for other purposes though, you can right click on the following links and select «Save Link As…» with the name of the link:</p><ul><li><code>[noise.json](http://opendata.caceres.es/GetData/GetData?dataset=om:MedicionRuido&amp;format=json)</code></li><li><code>[census.json](http://opendata.caceres.es/GetData/GetData?dataset=om:InformacionPadron&amp;year=2017&amp;format=json)</code></li><li><code>[vias.json](http://opendata.caceres.es/GetData/GetData?dataset=om:InformacionPadron&amp;year=2017&amp;format=json)</code></li><li><code>[trees.json](http://opendata.caceres.es/GetData/GetData?dataset=om:Arbol&amp;format=json)</code></li></ul><h2 id="backend"><a href="#backend">Backend</a></h2><p>It’s time to get started with some code! We will put it in a <code>server/</code> folder because it will contain the Python server, that is, the backend of our application.</p><p>We are using <code>aiohttp</code> because we would like our server to be <code>async</code>. We don’t expect a lot of users at the same time, but it’s good to know our server would be well-designed for that use-case. As a bonus, it makes IO points clear in the code, which can help reason about it. The implicit synchronization between <code>await</code> is also a nice bonus.</p><h3 id="saving-the-data-in-mongo"><a href="#saving-the-data-in-mongo">Saving the data in Mongo</a></h3><p>Before running the server, we must ensure that the data we need is already stored and indexed in Mongo. Our <code>server/data.py</code> will take care of downloading the files, cleaning them up a little (Cáceres’ OpenData can be a bit awkward sometimes), inserting them into Mongo and indexing them.</p><p>Downloading the JSON data can be done with <code>[ClientSession.get](https://aiohttp.readthedocs.io/en/stable/client_reference.html#aiohttp.ClientSession.get)</code>. We also take this opportunity to clean up the messy encoding from the JSON, which does not seem to be UTF-8 in some cases.</p><pre>async def load_json(session, url):
    fixes = [(old, new.encode('utf-8')) for old, new in [
        (b'\xc3\x83\\u2018', 'Ñ'),
        (b'\xc3\x83\\u0081', 'Á'),
        (b'\xc3\x83\\u2030', 'É'),
        (b'\xc3\x83\\u008D', 'Í'),
        (b'\xc3\x83\\u201C', 'Ó'),
        (b'\xc3\x83\xc5\xa1', 'Ú'),
        (b'\xc3\x83\xc2\xa1', 'á'),
    ]]

    async with session.get(url) as resp:
        data = await resp.read()

    # Yes, this feels inefficient, but it's not really worth improving.
    for old, new in fixes:
        data = data.replace(old, new)

    data = data.decode('utf-8')
    return json.loads(data)
</pre><p>Later on, it can be reused for the various different URLs:</p><pre>import aiohttp

NOISE_URL = 'http://opendata.caceres.es/GetData/GetData?dataset=om:MedicionRuido&amp;format=json'
# (...other needed URLs here)

async def insert_to_db(db):
    async with aiohttp.ClientSession() as session:
        data = await load_json(session, NOISE_URL)
        # now we have the JSON data cleaned up, ready to be parsed
</pre><h3 id="data-model"><a href="#data-model">Data model</a></h3><p>With the JSON data in our hands, it’s time to parse it. Always remember to <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">parse, don’t validate</a>. With <a href="https://docs.python.org/3/library/dataclasses.html">Python 3.7 <code>dataclasses</code></a> it’s trivial to define classes that will store only the fields we care about, typed, and with proper names:</p><pre>from dataclasses import dataclass

Longitude = float
Latitude = float

@dataclass
class GSON:
    type: str
    coordinates: (Longitude, Latitude)

@dataclass
class Noise:
    id: int
    geo: GSON
    level: float
</pre><p>This makes it really easy to see that, if we have a <code>Noise</code>, we can access its <code>geo</code> data which is a <code>GSON</code> with a <code>type</code> and <code>coordinates</code>, having <code>Longitude</code> and <code>Latitude</code> respectively. <code>dataclasses</code> and <code>[typing](https://docs.python.org/3/library/typing.html)</code> make dealing with this very easy and clear.</p><p>Every dataclass will be on its own collection inside Mongo, and these are:</p><ul><li>Noise</li><li>Integer <code>id</code></li><li>GeoJSON <code>geo</code></li><li>String <code>type</code></li><li>Longitude-latitude pair <code>coordinates</code></li><li>Floating-point number <code>level</code></li><li>Tree</li><li>String <code>name</code></li><li>String <code>gender</code></li><li>Integer <code>units</code></li><li>Floating-point number <code>height</code></li><li>Floating-point number <code>cup_diameter</code></li><li>Floating-point number <code>trunk_diameter</code></li><li>Optional string <code>variety</code></li><li>Optional string <code>distribution</code></li><li>GeoJSON <code>geo</code></li><li>Optional string <code>irrigation</code></li><li>Census</li><li>Integer <code>year</code></li><li>Via <code>via</code></li><li>String <code>name</code></li><li>String <code>kind</code></li><li>Integer <code>code</code></li><li>Optional string <code>history</code></li><li>Optional string <code>old_name</code></li><li>Optional floating-point number <code>length</code></li><li>Optional GeoJSON <code>start</code></li><li>GeoJSON <code>middle</code></li><li>Optional GeoJSON <code>end</code></li><li>Optional list with geometry pairs <code>geometry</code></li><li>Integer <code>count</code></li><li>Mapping year-to-count <code>count_per_year</code></li><li>Mapping gender-to-count <code>count_per_gender</code></li><li>Mapping nationality-to-count <code>count_per_nationality</code></li><li>Integer <code>time_year</code></li></ul><p>Now, let’s define a method to actually parse the JSON and yield instances from these new data classes:</p><pre>@classmethod
def iter_from_json(cls, data):
    for row in data['results']['bindings']:
        noise_id = int(row['uri']['value'].split('/')[-1])
        long = float(row['geo_long']['value'])
        lat = float(row['geo_lat']['value'])
        level = float(row['om_nivelRuido']['value'])

        yield cls(
            id=noise_id,
            geo=GSON(type='Point', coordinates=[long, lat]),
            level=level
        )
</pre><p>Here we iterate over the input JSON <code>data</code> bindings and <code>yield cls</code> instances with more consistent naming than the original one. We also extract the data from the many unnecessary nested levels of the JSON and have something a lot flatter to work with.</p><p>For those of you who don’t know what <code>yield</code> does (after all, not everyone is used to seeing generators), here’s two functions that work nearly the same:</p><pre>def squares_return(n):
    result = []
    for i in range(n):
        result.append(n ** 2)
    return result

def squares_yield(n):
    for i in range(n):
        yield n ** 2
</pre><p>The difference is that the one with <code>yield</code> is «lazy» and doesn’t need to do all the work up-front. It will generate (yield) more values as they are needed when you use a <code>for</code> loop. Generally, it’s a better idea to create generator functions than do all the work early which may be unnecessary. See <a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do">What does the «yield» keyword do?</a> if you still have questions.</p><p>With everything parsed, it’s time to insert the data into Mongo. If the data was not present yet (0 documents), then we will download the file, parse it, insert it as documents into the given Mongo <code>db</code>, and index it:</p><pre>from dataclasses import asdict

async def insert_to_db(db):
    async with aiohttp.ClientSession() as session:
        if await db.noise.estimated_document_count() == 0:
            data = await load_json(session, NOISE_URL)

            await db.noise.insert_many(asdict(noise) for noise in Noise.iter_from_json(data))
            await db.noise.create_index([('geo', '2dsphere')])
</pre><p>We repeat this process for all the other data, and just like that, Mongo is ready to be used in our server.</p><h3 id="indices"><a href="#indices">Indices</a></h3><p>In order to execute our geospatial queries we have to create an index on the attribute that represents the location, because the operators that we will use requires it. This attribute can be a <a href="https://docs.mongodb.com/manual/reference/geojson/">GeoJSON object</a> or a legacy coordinate pair.</p><p>We have decided to use a GeoJSON object because we want to avoid legacy features that may be deprecated in the future.</p><p>The attribute is called <code>geo</code> for the <code>Tree</code> and <code>Noise</code> objects and <code>start</code>, <code>middle</code> or <code>end</code> for the <code>Via</code> class. In the <code>Via</code> we are going to index the attribute <code>middle</code> because it is the most representative field for us. Because the <code>Via</code> is inside the <code>Census</code> and it doesn’t have its own collection, we create the index on the <code>Census</code> collection.</p><p>The used index type is <code>2dsphere</code> because it supports queries that work on geometries on an earth-like sphere. Another option is the <code>2d</code> index but it’s not a good fit for our because it is for queries that calculate geometries on a two-dimensional plane.</p><h3 id="running-the-server"><a href="#running-the-server">Running the server</a></h3><p>If we ignore the configuration part of the server creation, our <code>server.py</code> file is pretty simple. Its job is to create a <a href="https://aiohttp.readthedocs.io/en/stable/web.html">server application</a>, setup Mongo and return it to the caller so that they can run it:</p><pre>import asyncio
import subprocess
import motor.motor_asyncio

from aiohttp import web

from . import rest, data

def create_app():
    ret = subprocess.run('npm run build', cwd='../client', shell=True).returncode
    if ret != 0:
        exit(ret)

    db = motor.motor_asyncio.AsyncIOMotorClient().opendata
    loop = asyncio.get_event_loop()
    loop.run_until_complete(data.insert_to_db(db))

    app = web.Application()
    app['db'] = db

    app.router.add_routes([
        web.get('/', lambda r: web.HTTPSeeOther('/index.html')),
        *rest.ROUTES,
        web.static('/', os.path.join(config['www']['root'], 'public')),
    ])

    return app
</pre><p>There’s a bit going on here, but it’s nothing too complex:</p><ul><li>We automatically run <code>npm run build</code> on the frontend because it’s very comfortable to have the frontend built automatically before the server runs.</li><li>We create a Motor client and access the <code>opendata</code> database. Into it, we load the data, effectively saving it in Mongo for the server to use.</li><li>We create the server application and save a reference to the Mongo database in it, so that it can be used later on any endpoint without needing to recreate it.</li><li>We define the routes of our app: root, REST and static (where the frontend files live). We’ll get to the <code>rest</code> part soon. Running the server is now simple:</li></ul><pre>def main():
    from aiohttp import web
    from . import server

    app = server.create_app()
    web.run_app(app)

if __name__ == '__main__':
    main()
</pre><h3 id="rest-endpoints"><a href="#rest-endpoints">REST endpoints</a></h3><p>The frontend will communicate with the backend via <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> calls, so that it can ask for things like «give me the information associated with this area», and the web server can query the Mongo server to reply with a HTTP response. This little diagram should help:</p><p>![](bitmap.png)</p><p>What we need to do, then, is define those REST endpoints we mentioned earlier when creating the server. We will process the HTTP request, ask Mongo for the data, and return the HTTP response:</p><pre>import asyncio
import pymongo

from aiohttp import web

async def get_area_info(request):
    try:
        long = float(request.query['long'])
        lat = float(request.query['lat'])
        distance = float(request.query['distance'])
    except KeyError as e:
        raise web.HTTPBadRequest(reason=f'a required parameter was missing: {e.args[0]}')
    except ValueError:
        raise web.HTTPBadRequest(reason='one of the parameters was not a valid float')

    geo_avg_noise_pipeline = [{
        '$geoNear': {
            'near' : {'type': 'Point', 'coordinates': [long, lat]},
            'maxDistance': distance,
            'minDistance': 0,
            'spherical' : 'true',
            'distanceField' : 'distance'
        }
    }]

    db = request.app['db']

    try:
        noise_count, sum_noise, avg_noise = 0, 0, 0
        async for item in db.noise.aggregate(geo_avg_noise_pipeline):
            noise_count += 1
            sum_noise += item['level']

        if noise_count != 0:
            avg_noise = sum_noise / noise_count
        else:
            avg_noise = None

    except pymongo.errors.ConnectionFailure:
        raise web.HTTPServiceUnavailable(reason='no connection to database')

    return web.json_response({
        'tree_count': tree_count,
        'trees_per_type': [[k, v] for k, v in trees_per_type.items()],
        'census_count': census_count,
        'avg_noise': avg_noise,
    })

ROUTES = [
    web.get('/rest/get-area-info', get_area_info)
]
</pre><p>In this code, we’re only showing how to return the average noise because that’s the simplest we can do. The real code also fetches tree count, tree count per type, and census count.</p><p>Again, there’s quite a bit to go through, so let’s go step by step:</p><ul><li>We parse the frontend’s <code>request.query</code> into <code>float</code> that we can use. In particular, the frontend is asking us for information at a certain latitude, longitude, and distance. If the query is malformed, we return a proper error.</li><li>We create our query for Mongo outside, just so it’s clearer to read.</li><li>We access the database reference we stored earlier when creating the server with <code>request.app['db']</code>. Handy!</li><li>We try to query Mongo. It may fail if the Mongo server is not running, so we should handle that and tell the client what’s happening. If it succeeds though, we will gather information about the average noise.</li><li>We return a <code>json_response</code> with Mongo results for the frontend to present to the user. You may have noticed we defined a <code>ROUTES</code> list at the bottom. This will make it easier to expand in the future, and the server creation won’t need to change anything in its code, because it’s already unpacking all the routes we define here.</li></ul><h3 id="geospatial-queries"><a href="#geospatial-queries">Geospatial queries</a></h3><p>In order to retrieve the information from Mongo database we have defined two geospatial queries:</p><pre>geo_query = {
    '$nearSphere' : {
        '$geometry': {
            'type': 'Point',
            'coordinates': [long, lat]
         },
        '$maxDistance': distance,
        '$minDistance': 0
    }
}
</pre><p>This query uses <a href="https://docs.mongodb.com/manual/reference/operator/query/nearSphere/#op._S_nearSphere">the operator <code>$nearSphere</code></a> which return geospatial objects in proximity to a point on a sphere.</p><p>The sphere point is represented by the <code>$geometry</code> operator where it is specified the type of geometry and the coordinates (given by the HTTP request).</p><p>The maximum and minimum distance are represented by <code>$maxDistance</code> and <code>$minDistance</code> respectively. We specify that the maximum distance is the radio selected by the user.</p><pre>geo_avg_noise_pipeline = [{
    '$geoNear': {
        'near' : {'type': 'Point', 'coordinates': [long, lat]},
        'maxDistance': distance,
        'minDistance': 0,
        'spherical' : 'true',
        'distanceField' : 'distance'
    }
}]
</pre><p>This query uses the <a href="https://docs.mongodb.com/manual/core/aggregation-pipeline/">aggregation pipeline</a> stage <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/geoNear/#pipe._S_geoNear"><code>$geoNear</code></a> which returns an ordered stream of documents based on the proximity to a geospatial point. The output documents include an additional distance field.</p><p>The <code>near</code> field is mandatory and is the point for which to find the closest documents. In this field it is specified the type of geometry and the coordinates (given by the HTTP request).</p><p>The <code>distanceField</code> field is also mandatory and is the output field that will contain the calculated distance. In this case we’ve just called it <code>distance</code>.</p><p>Some other fields are <code>maxDistance</code> that indicates the maximum allowed distance from the center of the point, <code>minDistance</code> for the minimum distance, and <code>spherical</code> which tells MongoDB how to calculate the distance between two points.</p><p>We specify the maximum distance as the radio selected by the user in the frontend.</p><h2 id="frontend"><a href="#frontend">Frontend</a></h2><p>As said earlier, our frontend will use Svelte. We already downloaded the template, so we can start developing. For some, this is the most fun part, because they can finally see and interact with some of the results. But for this interaction to work, we needed a functional backend which we now have!</p><h3 id="rest-queries"><a href="#rest-queries">REST queries</a></h3><p>The frontend has to query the server to get any meaningful data to show on the page. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> does not throw an exception if the server doesn’t respond with HTTP OK, but we would like one if things go wrong, so that we can handle them gracefully. The first we’ll do is define our own exception <a href="https://stackoverflow.com/a/27724419">which is not pretty</a>:</p><pre>function NetworkError(message, status) {
    var instance = new Error(message);
    instance.name = 'NetworkError';
    instance.status = status;
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    if (Error.captureStackTrace) {
        Error.captureStackTrace(instance, NetworkError);
    }
    return instance;
}

NetworkError.prototype = Object.create(Error.prototype, {
    constructor: {
        value: Error,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Object.setPrototypeOf(NetworkError, Error);
</pre><p>But hey, now we have a proper and reusable <code>NetworkError</code>! Next, let’s make a proper and reusabe <code>query</code> function that deals with <code>fetch</code> for us:</p><pre>async function query(endpoint) {
    const res = await fetch(endpoint, {
        // if we ever use cookies, this is important
        credentials: 'include'
    });
    if (res.ok) {
        return await res.json();
    } else {
        throw new NetworkError(await res.text(), res.status);
    }
}
</pre><p>At last, we can query our web server. The export here tells Svelte that this function should be visible to outer modules (public) as opposed to being private:</p><pre>export function get_area_info(long, lat, distance) {
    return query(`/rest/get-area-info?long=${long}&amp;lat=${lat}&amp;distance=${distance}`);
}
</pre><p>The attentive reader will have noticed that <code>query</code> is <code>async</code>, but <code>get_area_info</code> is not. This is intentional, because we don’t need to <code>await</code> for anything inside of it. We can just return the <code>[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)</code> that <code>query</code> created and let the caller <code>await</code> it as they see fit. The <code>await</code> here would have been redundant.</p><p>For those of you who don’t know what a JavaScript promise is, think of it as an object that represents «an eventual result». The result may not be there yet, but we promised it will be present in the future, and we can <code>await</code> for it. You can also find the same concept in other languages like Python under a different name, such as <a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future"><code>Future</code></a>.</p><h3 id="map-component"><a href="#map-component">Map component</a></h3><p>In Svelte, we can define self-contained components that are issolated from the rest. This makes it really easy to create a modular application. Think of a Svelte component as your own HTML tag, which you can customize however you want, building upon the already-existing components HTML has to offer.</p><p>The main thing that our map needs to do is render the map as an image and overlay the selection area as the user hovers the map with their mouse. We could render the image in the canvas itself, but instead we’ll use the HTML <code>&lt;img&gt;</code> tag for that and put a transparent <code>&lt;canvas&gt;</code> on top with some CSS. This should make it cheaper and easier to render things on the canvas.</p><p>The <code>Map</code> component will thus render as the user moves the mouse over it, and produce an event when they click so that whatever component is using a <code>Map</code> knows that it was clicked. Here’s the final CSS and HTML:</p><pre>&lt;style&gt;
div {
    position: relative;
}
canvas {
    position: absolute;
    left: 0;
    top: 0;
    cursor: crosshair;
}
&lt;/style&gt;

&lt;div&gt;
    &lt;img bind:this={img} on:load={handleLoad} {height} src="caceres-municipality.svg" alt="Cáceres (municipality)"/&gt;
    &lt;canvas
        bind:this={canvas}
        on:mousemove={handleMove}
        on:wheel={handleWheel}
        on:mouseup={handleClick}/&gt;
&lt;/div&gt;
</pre><p>We hardcode a map source here, but ideally this would be provided by the server. The project is already complex enough, so we tried to avoid more complexity than necessary.</p><p>We bind the tags to some variables declared in the JavaScript code of the component, along with some functions and parameters to let the users of <code>Map</code> customize it just a little.</p><p>Here’s the gist of the JavaScript code:</p><pre>&lt;script&gt;
    import { createEventDispatcher, onMount } from 'svelte';

    export let height = 200;

    const dispatch = createEventDispatcher();

    let img;
    let canvas;

    const LONG_WEST = -6.426881;
    const LONG_EAST = -6.354143;
    const LAT_NORTH = 39.500064;
    const LAT_SOUTH = 39.443201;

    let x = 0;
    let y = 0;
    let clickInfo = null; // [x, y, radius]
    let radiusDelta = 0.005 * height;
    let maxRadius = 0.2 * height;
    let minRadius = 0.01 * height;
    let radius = 0.05 * height;

    function handleLoad() {
        canvas.width = img.width;
        canvas.height = img.height;
    }

    function handleMove(event) {
        const { left, top } = this.getBoundingClientRect();
        x = Math.round(event.clientX - left);
        y = Math.round(event.clientY - top);
    }

    function handleWheel(event) {
        if (event.deltaY &lt; 0) {
            if (radius &lt; maxRadius) {
                radius += radiusDelta;
            }
        } else {
            if (radius &gt; minRadius) {
                radius -= radiusDelta;
            }
        }
        event.preventDefault();
    }

    function handleClick(event) {
        dispatch('click', {
            // the real code here maps the x/y/radius values to the right range, here omitted
            x: ...,
            y: ...,
            radius: ...,
        });
    }

    onMount(() =&gt; {
        const ctx = canvas.getContext('2d');
        let frame;

        (function loop() {
            frame = requestAnimationFrame(loop);

            // the real code renders mouse area/selection, here omitted for brevity
            ...
        }());

        return () =&gt; {
            cancelAnimationFrame(frame);
        };
    });
&lt;/script&gt;
</pre><p>Let’s go through bit-by-bit:</p><ul><li>We define a few variables and constants for later use in the final code.</li><li>We define the handlers to react to mouse movement and clicks. On click, we dispatch an event to outer components.</li><li>We setup the render loop with animation frames, and cancel the current frame appropriatedly if the component disappears.</li></ul><h3 id="app-component"><a href="#app-component">App component</a></h3><p>Time to put everything together! We wil include our function to make REST queries along with our <code>Map</code> component to render things on screen.</p><pre>&lt;script&gt;
    import Map from './Map.svelte';
    import { get_area_info } from './rest.js'
    let selection = null;
    let area_info_promise = null;
    function handleMapSelection(event) {
        selection = event.detail;
        area_info_promise = get_area_info(selection.x, selection.y, selection.radius);
    }
    function format_avg_noise(avg_noise) {
        if (avg_noise === null) {
            return '(no data)';
        } else {
            return `${avg_noise.toFixed(2)} dB`;
        }
    }
&lt;/script&gt;

&lt;div class="container-fluid"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-3" style="max-width: 300em;"&gt;
            &lt;div class="text-center"&gt;
                &lt;h1&gt;Caceres Data Consultory&lt;/h1&gt;
            &lt;/div&gt;
            &lt;Map height={400} on:click={handleMapSelection}/&gt;
            &lt;div class="text-center mt-4"&gt;
                {#if selection === null}
                        &lt;p class="m-1 p-3 border border-bottom-0 bg-info text-white"&gt;Click on the map to select the area you wish to see details for.&lt;/p&gt;
                {:else}
                        &lt;h2 class="bg-dark text-white"&gt;Selected area&lt;/h2&gt;
                        &lt;p&gt;&lt;b&gt;Coordinates:&lt;/b&gt; ({selection.x}, {selection.y})&lt;/p&gt;
                        &lt;p&gt;&lt;b&gt;Radius:&lt;/b&gt; {selection.radius} meters&lt;/p&gt;
                {/if}
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-sm-4"&gt;
            &lt;div class="row"&gt;
            {#if area_info_promise !== null}
                {#await area_info_promise}
                    &lt;p&gt;Fetching area information…&lt;/p&gt;
                {:then area_info}
                    &lt;div class="col"&gt;
                        &lt;div class="text-center"&gt;
                            &lt;h2 class="m-1 bg-dark text-white"&gt;Area information&lt;/h2&gt;
                            &lt;ul class="list-unstyled"&gt;
                                &lt;li&gt;There are &lt;b&gt;{area_info.tree_count} trees &lt;/b&gt; within the area&lt;/li&gt;
                                &lt;li&gt;The &lt;b&gt;average noise&lt;/b&gt; is &lt;b&gt;{format_avg_noise(area_info.avg_noise)}&lt;/b&gt;&lt;/li&gt;
                                &lt;li&gt;There are &lt;b&gt;{area_info.census_count} persons &lt;/b&gt; within the area&lt;/li&gt;
                            &lt;/ul&gt;
                        &lt;/div&gt;
                        {#if area_info.trees_per_type.length &gt; 0}
                            &lt;div class="text-center"&gt;
                                &lt;h2 class="m-1 bg-dark text-white"&gt;Tree count per type&lt;/h2&gt;
                            &lt;/div&gt;
                            &lt;ul class="list-group"&gt;
                                {#each area_info.trees_per_type as [type, count]}
                                    &lt;li class="list-group-item"&gt;{type} &lt;span class="badge badge-dark float-right"&gt;{count}&lt;/span&gt;&lt;/li&gt;
                                {/each}
                            &lt;/ul&gt;
                        {/if}
                    &lt;/div&gt;
                {:catch error}
                    &lt;p&gt;Failed to fetch area information: {error.message}&lt;/p&gt;
                {/await}
            {/if}
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre><ul><li>We import the <code>Map</code> component and REST function so we can use them.</li><li>We define a listener for the events that the <code>Map</code> produces. Such event will trigger a REST call to the server and save the result in a promise used later.</li><li>We’re using Bootstrap for the layout because it’s a lot easier. In the body we add our <code>Map</code> and another column to show the selection information.</li><li>We make use of Svelte’s <code>{#await}</code> to nicely notify the user when the call is being made, when it was successful, and when it failed. If it’s successful, we display the info.</li></ul><h2 id="results"><a href="#results">Results</a></h2><p>Lo and behold, watch our application run!</p><video controls="controls" src="sr-2020-04-14_09-28-25.mp4"></video><p>In this video you can see our application running, but let’s describe what is happening in more detail.</p><p>When the application starts running (by opening it in your web browser of choice), you can see a map with the town of Cáceres. Then you, the user, can click to retrieve the information within the selected area.</p><p>It is important to note that one can make the selection area larger or smaller by trying to scroll up or down, respectively.</p><p>Once an area is selected, it is colored green in order to let the user know which area they have selected. Under the map, the selected coordinates and the radius (in meters) is also shown for the curious. At the right side the information concerning the selected area is shown, such as the number of trees, the average noise and the number of persons. If there are trees in the area, the application also displays the trees per type, sorted by the number of trees.</p><h2 id="download"><a href="#download">Download</a></h2><p>We hope you enjoyed reading this post as much as we enjoyed writing it! Feel free to download the final project and play around with it. Maybe you can adapt it for even more interesting purposes!</p><p><em>download removed</em></p><p>To run the above code:</p><ol><li>Unzip the downloaded file.</li><li>Make a copy of <code>example-server-config.ini</code> and rename it to <code>server-config.ini</code>, then edit the file to suit your needs.</li><li>Run the server with <code>python -m server</code>.</li><li>Open <a href="http://localhost:9000">localhost:9000</a> in your web browser (or whatever port you chose) and enjoy!</li></ol></article></main><footer><p> Share your thoughts! —
<a href="mailto:totufals@hotmail.com"><img src="/img/mail.svg" alt="Mail"></a> </p><p class="abyss" onclick="egg()">Gaze into the abyss… Oh hi there!</p></footer><script>
      const egg = () => {
    const audio = document.createElement('audio')
    audio.src = 'https://oriath.net/Audio/Dialogue/NPC/ShaperCombat/SH25b.dialogue.ogg'
    audio.play()
}
    </script></body></html>