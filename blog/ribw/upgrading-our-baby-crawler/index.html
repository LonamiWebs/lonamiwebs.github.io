<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=description content="Official Lonami's website"><meta name=viewport content="width=device-width, initial-scale=1.0, user-scalable=yes"><title> Upgrading our Baby Crawler | Lonami's Blog </title><link rel=stylesheet href=/style.css><body><nav class=sections><ul><li><a href=/>lonami's site</a><li><a href=/blog class=selected>blog</a><li><a href=/golb>golb</a></ul></nav><main><h1 class=title>Upgrading our Baby Crawler</h1><div class=time><p>2020-03-11T00:00:07+00:00<p>last updated 2020-03-18T09:49:33+00:00</div><p>In our <a href=/blog/ribw/build-your-own-pc/>last post on this series</a>, we presented the code for our Personal Crawler. However, we didn’t quite explain what a crawler even is! We will use this moment to go a bit more in-depth, and make some upgrades to it.<h2 id=what-is-a-crawler>What is a Crawler?</h2><p>A crawler is a program whose job is to analyze documents and extract data from them. For example, search engines like <a href=http://duckduckgo.com/>DuckDuckGo</a>, <a href=https://bing.com/>Bing</a> or <a href=http://google.com/>Google</a> all have crawlers to analyze websites and build a database around them. They are some kind of «trackers», because they keep track of everything they find.<p>Their basic behaviour can be described as follows: given a starting list of URLs, follow them all and identify hyperlinks inside the documents. Add these to the list of links to follow, and repeat <em>ad infinitum</em>.<ul><li>This lets us create an index to quickly search across them all.<li>We can also identify broken links.<li>We can gather any other type of information that we found. Our crawler will work offline, within our own computer, scanning the text documents it finds on the root we tell it to scan.</ul><h2 id=design-decissions>Design Decissions</h2><ul><li>We will use Java. Its runtime is quite ubiquitous, so it should be able to run in virtually anywhere. The language is typed, which helps catch errors early on.<li>Our solution is iterative. While recursion can be seen as more elegants by some, iterative solutions are often more performant with less need for optimization.</ul><h2 id=requirements>Requirements</h2><p>If you don’t have Java installed yet, you can <a href=https://java.com/en/download/>Download Free Java Software</a> from Oracle’s site. To compile the code, the <a href=https://www.oracle.com/java/technologies/javase-jdk8-downloads.html>Java Development Kit</a> is also necessary.<p>We don’t depend on any other external libraries, for easier deployment and compilation.<h2 id=implementation>Implementation</h2><p>Because the code was getting pretty large, it has been split into several files, and we have also upgraded it to use a Graphical User Interface instead! We decided to use Swing, based on the Java tutorial <a href=https://docs.oracle.com/javase/tutorial/uiswing/>Creating a GUI With JFC/Swing</a>.<h3 id=app>App</h3><p>This file is the entry point of our application. Its job is to initialize the components, lay them out in the main panel, and connect the event handlers.<p>Most widgets are pretty standard, and are defined as class variables. However, some variables are notable. The <code>[DefaultTableModel](https://docs.oracle.com/javase/8/docs/api/javax/swing/table/DefaultTableModel.html)</code> is used because it allows to <a href=https://stackoverflow.com/a/22550106>dynamically add rows</a>, and we also have a <code>[SwingWorker](https://docs.oracle.com/javase/8/docs/api/javax/swing/SwingWorker.html)</code> subclass responsible for performing the word analysis (which is quite CPU intensive and should not be ran in the UI thread!).<p>There’s a few utility methods to ease some common operations, such as <code>updateStatus</code> which changes the status label in the main window, informing the user of the latest changes.<h3 id=thesaurus>Thesaurus</h3><p>A thesaurus is a collection of words or terms used to represent concepts. In literature this is commonly known as a dictionary.<p>On the subject of this project, we are using a thesaurus based on how relevant is a word for the meaning of a sentence, filtering out those that barely give us any information.<p>This file contains a simple thesaurus implementation, which can trivially be used as a normal or inverted thesaurus. However, we only treat it as inverted, and its job is loading itself and determining if words are valid or should otherwise be ignored.<h3 id=utils>Utils</h3><p>Several utility functions used across the codebase.<h3 id=wordmap>WordMap</h3><p>This file is the important one, and its implementation hasn’t changed much since our last post. Instances of a word map contain… wait for it… a map of words! It stores the mapping <code>word → count</code> in memory, and offers methods to query the count of a word or iterate over the word count entries.<p>It can be loaded from cache or told to analyze a root path. Once an instance is created, additional files could be analyzed one by one if desired.<h2 id=download>Download</h2><p>The code was getting a bit too large to embed it within the blog post itself, so instead you can download it as a<code>.zip</code> file.<p><em>download removed</em></main>