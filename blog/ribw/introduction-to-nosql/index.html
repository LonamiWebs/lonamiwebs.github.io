<!doctype html><html lang=en><head><meta charset=utf-8><meta content="Official Lonami's website" name=description><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name=viewport><title> Introduction to NoSQL | Lonami's Blog </title><link href=/style.css rel=stylesheet><body><article><nav class=sections><ul class=left><li><a href=/>lonami's site</a><li><a class=selected href=/blog>blog</a><li><a href=/golb>golb</a></ul><div class=right><a href=https://github.com/LonamiWebs><img alt=github src=/img/github.svg></a><a href=/blog/atom.xml><img alt=rss src=/img/rss.svg></a></div></nav><main><h1 class=title>Introduction to NoSQL</h1><div class=time><p>2020-02-25T01:00:15+00:00<p>last updated 2020-03-18T09:38:23+00:00</div><p>This post will primarly focus on the talk held in the <a href=https://youtu.be/qI_g07C_Q5I>GOTO 2012 conference: Introduction to NoSQL by Martin Fowler</a>. It can be seen as an informal, summarized transcript of the talk<hr><p>The relational database model is affected by the <em><a href=https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch>impedance mismatch problem</a></em>. This occurs because we have to match our high-level design with the separate columns and rows used by relational databases.<p>Taking the in-memory objects and putting them into a relational database (which were dominant at the time) simply didn’t work out. Why? Relational databases were more than just databases, they served as a an integration mechanism across applications, up to the 2000s. For 20 years!<p>With the rise of the Internet and the sheer amount of traffic, databases needed to scale. Unfortunately, relational databases only scale well vertically (by upgrading a <em>single</em> node). This is <em>very</em> expensive, and not something many could afford.<p>The problem are those pesky <code>JOIN</code>‘s, and its friends <code>GROUP BY</code>. Because our program and reality model don’t match the tables used by SQL, we have to rely on them to query the data. It is because the model doesn’t map directly.<p>Furthermore, graphs don’t map very well at all to relational models.<p>We needed a way to scale horizontally (by increasing the <em>amount</em> of nodes), something relational databases were not designed to do.<blockquote><p><em>We need to do something different, relational across nodes is an unnatural act</em></blockquote><p>This inspired the NoSQL movement.<blockquote><p><em>#nosql was only meant to be a hashtag to advertise it, but unfortunately it’s how it is called now</em></blockquote><p>It is not possible to define NoSQL, but we can identify some of its characteristics:<ul><li><p>Non-relational</p><li><p><strong>Cluster-friendly</strong> (this was the original spark)</p><li><p>Open-source (until now, generally)</p><li><p>21st century web culture</p><li><p>Schema-less (easier integration or conjugation of several models, structure aggregation) These databases use different data models to those used by the relational model. However, it is possible to identify 4 broad chunks (some may say 3, or even 2!):</p><li><p><strong>Key-value store</strong>. With a certain key, you obtain the value corresponding to it. It knows nothing else, nor does it care. We say the data is opaque.</p><li><p><strong>Document-based</strong>. It stores an entire mass of documents with complex structure, normally through the use of JSON (XML has been left behind). Then, you can ask for certain fields, structures, or portions. We say the data is transparent.</p><li><p><strong>Column-family</strong>. There is a «row key», and within it we store multiple «column families» (columns that fit together, our aggregate). We access by row-key and column-family name. All of these kind of serve to store documents without any <em>explicit</em> schema. Just shove in anything! This gives a lot of flexibility and ease of migration, except… that’s not really true. There’s an <em>implicit</em> schema when querying.</p></ul><p>For example, a query where we may do <code>anOrder['price'] * anOrder['quantity']</code> is assuming that <code>anOrder</code> has both a <code>price</code> and a <code>quantity</code>, and that both of these can be multiplied together. «Schema-less» is a fuzzy term.<p>However, it is the lack of a <em>fixed</em> schema that gives flexibility.<p>One could argue that the line between key-value and document-based is very fuzzy, and they would be right! Key-value databases often let you include additional metadata that behaves like an index, and in document-based, documents often have an identifier anyway.<p>The common notion between these three types is what matters. They save an entire structure as an <em>unit</em>. We can refer to these as «Aggregate Oriented Databases». Aggregate, because we group things when designing or modeling our systems, as opposed to relational databases that scatter the information across many tables.<p>There exists a notable outlier, though, and that’s:<ul><li><strong>Graph</strong> databases. They use a node-and-arc graph structure. They are great for moving on relationships across things. Ironically, relational databases are not very good at jumping across relationships! It is possibly to perform very interesting queries in graph databases which would be really hard and costly on relational models. Unlike the aggregated databases, graphs break things into even smaller units. NoSQL is not <em>the</em> solution. It depends on how you’ll work with your data. Do you need an aggregate database? Will you have a lot of relationships? Or would the relational model be good fit for you?</ul><p>NoSQL, however, is a good fit for large-scale projects (data will <em>always</em> grow) and faster development (the impedance mismatch is drastically reduced).<p>Regardless of our choice, it is important to remember that NoSQL is a young technology, which is still evolving really fast (SQL has been stable for <em>decades</em>). But the <em>polyglot persistence</em> is what matters. One must know the alternatives, and be able to choose.<hr><p>Relational databases have the well-known ACID properties: Atomicity, Consistency, Isolation and Durability.<p>NoSQL (except graph-based!) are about being BASE instead: Basically Available, Soft state, Eventual consistency.<p>SQL needs transactions because we don’t want to perform a read while we’re only half-way done with a write! The readers and writers are the problem, and ensuring consistency results in a performance hit, even if the risk is low (two writers are extremely rare but it still must be handled).<p>NoSQL on the other hand doesn’t need ACID because the aggregate <em>is</em> the transaction boundary. Even before NoSQL itself existed! Any update is atomic by nature. When updating many documents it <em>is</em> a problem, but this is very rare.<p>We have to distinguish between logical and replication consistency. During an update and if a conflict occurs, it must be resolved to preserve the logical consistency. Replication consistency on the other hand is preserveed when distributing the data across many machines, for example during sharding or copies.<p>Replication buys us more processing power and resillence (at the cost of more storage) in case some of the nodes die. But what happens if what dies is the communication across the nodes? We could drop the requests and preserve the consistency, or accept the risk to continue and instead preserve the availability.<p>The choice on whether trading consistency for availability is acceptable or not depends on the domain rules. It is the domain’s choice, the business people will choose. If you’re Amazon, you always want to be able to sell, but if you’re a bank, you probably don’t want your clients to have negative numbers in their account!<p>Regardless of what we do, in a distributed system, the CAP theorem always applies: Consistecy, Availability, Partitioning-tolerancy (error tolerancy). It is <strong>impossible</strong> to guarantee all 3 at 100%. Most of the times, it does work, but it is mathematically impossible to guarantee at 100%.<p>A database has to choose what to give up at some point. When designing a distributed system, this must be considered. Normally, the choice is made between consistency or response time.<h2 id=further-reading>Further reading</h2><ul><li><a href=https://www.martinfowler.com/articles/nosql-intro-original.pdf>The future is: <del>NoSQL Databases</del> Polyglot Persistence</a><li><a href=https://www.thoughtworks.com/insights/blog/nosql-databases-overview>NoSQL Databases: An Overview</a></ul></main><footer><div><p>Share your thoughts! — <a href=mailto:totufals@hotmail.com><img alt=Mail src=/img/mail.svg></a></div></footer></article><p class=abyss onclick=egg()>Gaze into the abyss… Oh hi there!</p><script>const egg = () => {
    const audio = document.createElement('audio')
    audio.src = 'https://oriath.net/Audio/Dialogue/NPC/ShaperCombat/SH25b.dialogue.ogg'
    audio.play()
}</script>