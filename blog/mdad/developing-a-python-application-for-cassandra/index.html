<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Developing a Python application for Cassandra</title>
<link rel="stylesheet" href="../css/style.css">
</head>
<body>
<main>
<p><em><strong>Warning</strong>: this post is, in fact, a shameless self-plug to my own library. If you continue reading, you accept that you are okay with this. Otherwise, please close the tab, shut down your computer, and set it on fire.__(Also, that was a joke. Please don’t do that.)</em></p>
<div class="date-created-modified">Created 2020-03-23<br>
Modified 2020-04-16</div>
<p>Let’s do some programming! Today we will be making a tiny CLI application in <a href="http://python.org/">Python</a> that queries <a href="https://core.telegram.org/api">Telegram’s API</a> and stores the data in <a href="http://cassandra.apache.org/">Cassandra</a>.</p>
<h2 class="title" id="our_goal"><a class="anchor" href="#our_goal">¶</a>Our goal</h2>
<p>Our goal is to make a Python console application. This application will connect to <a href="https://telegram.org/">Telegram</a>, and ask for your account credentials. Once you have logged in, the application will fetch all of your open conversations and we will store these in Cassandra.</p>
<p>With the data saved in Cassandra, we can now very efficiently query information about your conversations given their identifier offline (no need to query Telegram anymore).</p>
<p><strong>In short</strong>, we are making an application that performs efficient offline queries to Cassandra to print out information about your Telegram conversations given the ID you want to query.</p>
<h2 id="data_model"><a class="anchor" href="#data_model">¶</a>Data model</h2>
<p>The application itself is really simple, and we only need one table to store all the relevant information we will be needing. This table called <code>**users**</code> will contain the following columns:</p>
<ul>
<li><code>**id**</code>, of type <code>int</code>. This will also be the <code>primary key</code> and we’ll use it to query the database later on.</li>
<li><code>**first_name**</code>, of type <code>varchar</code>. This field contains the first name of the stored user.</li>
<li><code>**last_name**</code>, of type <code>varchar</code>. This field contains the last name of the stored user.</li>
<li><code>**username**</code>, of type <code>varchar</code>. This field contains the username of the stored user.
Because Cassandra uses a <a href="https://cassandra.apache.org/doc/latest/architecture/overview.html">wide column storage model</a>, direct access through a key is the most efficient way to query the database. In our case, the key is the primary key of the <code>users</code> table, using the <code>id</code> column. The index for the primary key is ready to be used as soon as we create the table, so we don’t need to create it on our own.</li>
</ul>
<h2 id="dependencies"><a class="anchor" href="#dependencies">¶</a>Dependencies</h2>
<p>Because we will program it in Python, you need Python installed. You can install it using a package manager of your choice or heading over to the <a href="https://www.python.org/downloads/">Python downloads section</a>, but if you’re on Linux, chances are you have it installed already.</p>
<p>Once Python 3.5 or above is installed, get a copy of the Cassandra driver for Python and Telethon through <code>pip</code>:</p>
<pre><code>pip install cassandra-driver telethon
</code></pre>
<p>For more details on that, see the <a href="https://docs.datastax.com/en/developer/python-driver/3.22/installation/">installation guide for <code>cassandra-driver</code></a>, or the <a href="https://docs.telethon.dev/en/latest/basic/installation.html">installation guide for <code>telethon</code></a>.</p>
<p>As we did in our <a href="/blog/mdad/cassandra-operaciones-basicas-y-arquitectura/">previous post</a>, we will setup a new keyspace for this application with <code>cqlsh</code>. We will also create a table to store the users into. This could all be automated in the Python code, but because it’s a one-time thing, we prefer to use <code>cqlsh</code>.</p>
<p>Make sure that Cassandra is running in the background. We can’t make queries to it if it’s not running.</p>
<pre><code>$ bin/cqlsh
Connected to Test Cluster at 127.0.0.1:9042.
[cqlsh 5.0.1 | Cassandra 3.11.6 | CQL spec 3.4.4 | Native protocol v4]
Use HELP for help.
cqlsh&gt; create keyspace mdad with replication = {'class': 'SimpleStrategy', 'replication_factor': 3};
cqlsh&gt; use mdad;
cqlsh:mdad&gt; create table users(id int primary key, first_name varchar, last_name varchar, username varchar);
</code></pre>
<p>Python installed? Check. Python dependencies? Check. Cassandra ready? Check.</p>
<h2 id="the_code"><a class="anchor" href="#the_code">¶</a>The code</h2>
<h3 id="getting_users"><a class="anchor" href="#getting_users">¶</a>Getting users</h3>
<p>The first step is connecting to <a href="https://core.telegram.org/api">Telegram’s API</a>, for which we’ll use <a href="https://telethon.dev/">Telethon</a>, a wonderful (wink, wink) Python library to interface with it.</p>
<p>As with most APIs, we need to supply <a href="https://my.telegram.org/">our API key</a> in order to use it (here <code>API_ID</code> and <code>API_HASH</code>). We will refer to them as constants. At the end, you may download the entire code and use my own key for this example. But please don’t use those values for your other applications!</p>
<p>It’s pretty simple: we create a client, and for every dialog (that is, open conversation) we have, do some checks:</p>
<ul>
<li>If it’s an user, we just store that in a dictionary mapping <code>ID → User</code>.</li>
<li>Else if it’s a group, we iterate over the participants and store those users instead.</li>
</ul>
<pre><code>async def load_users():
    from telethon import TelegramClient

    users = {}

    async with TelegramClient(SESSION, API_ID, API_HASH) as client:
        async for dialog in client.iter_dialogs():
            if dialog.is_user:
                user = dialog.entity
                users[user.id] = user
                print('found user:', user.id, file=sys.stderr)

            elif dialog.is_group:
                async for user in client.iter_participants(dialog):
                    users[user.id] = user
                    print('found member:', user.id, file=sys.stderr)

    return list(users.values())
</code></pre>
<p>With this we have a mapping ID to user, so we know we won’t have duplicates. We simply return the list of user values, because that’s all we care about.</p>
<h3 id="saving_users"><a class="anchor" href="#saving_users">¶</a>Saving users</h3>
<p>Inserting users into Cassandra is pretty straightforward. We take the list of <code>User</code> objects as input, and prepare a new <code>INSERT</code> statement that we can reuse (because we will be using it in a loop, this is the best way to do it).</p>
<p>For each user, execute the statement with the user data as input parameters. Simple as that.</p>
<pre><code>def save_users(session, users):
    insert_stmt = session.prepare(
        'INSERT INTO users (id, first_name, last_name, username) ' 
        'VALUES (?, ?, ?, ?)')

    for user in users:
        row = (user.id, user.first_name, user.last_name, user.username)
        session.execute(insert_stmt, row)
</code></pre>
<h3 id="fetching_users"><a class="anchor" href="#fetching_users">¶</a>Fetching users</h3>
<p>Given a list of users, yield all of them from the database. Similar to before, we prepare a <code>SELECT</code> statement and just execute it repeatedly over the input user IDs.</p>
<pre><code>def fetch_users(session, users):
    select_stmt = session.prepare('SELECT * FROM users WHERE id = ?')

    for user_id in users:
        yield session.execute(select_stmt, (user_id,)).one()
</code></pre>
<h3 id="parsing_arguments"><a class="anchor" href="#parsing_arguments">¶</a>Parsing arguments</h3>
<p>We’ll be making a little CLI application, so we need to parse console arguments. It won’t be anything fancy, though. For that we’ll be using <a href="https://docs.python.org/3/library/argparse.html">Python’s <code>argparse</code> module</a>:</p>
<pre><code>def parse_args():
    import argparse

    parser = argparse.ArgumentParser(
        description='Dump and query Telegram users')

    parser.add_argument('users', type=int, nargs='*',
        help='one or more user IDs to query for')

    parser.add_argument('--load-users', action='store_true',
        help='load users from Telegram (do this first run)')

    return parser.parse_args()
</code></pre>
<h3 id="all_together"><a class="anchor" href="#all_together">¶</a>All together</h3>
<p>Last, the entry point. We import a Cassandra Cluster, and connect to some default keyspace (we called it <code>mdad</code> earlier).</p>
<p>If the user wants to load the users into the database, we’ll do just that first.</p>
<p>Then, for each user we fetch from the database, we print it. Last names and usernames are optional, so don’t print those if they’re missing (<code>None</code>).</p>
<pre><code>async def main(args):
    from cassandra.cluster import Cluster

    cluster = Cluster(CLUSTER_NODES)
    session = cluster.connect(KEYSPACE)

    if args.load_users:
        users = await load_users()
        save_users(session, users)

    for user in fetch_users(session, args.users):
        print('User', user.id, ':')
        print('  First name:', user.first_name)
        if user.last_name:
            print('  Last name:', user.last_name)
        if user.username:
            print('  Username:', user.username)

        print()

if __name__ == '__main__':
    asyncio.run(main(parse_args()))
</code></pre>
<p>Because Telethon is an <code>[asyncio](https://docs.python.org/3/library/asyncio.html)</code> library, we define it as <code>async def main(...)</code> and run it with <code>asyncio.run(main(...))</code>.</p>
<p>Here’s what it looks like in action:</p>
<pre><code>$ python data.py --help
usage: data.py [-h] [--load-users] [users [users ...]]

Dump and query Telegram users

positional arguments:
  users         one or more user IDs to query for

optional arguments:
  -h, --help    show this help message and exit
  --load-users  load users from Telegram (do this first run)

$ python data.py --load-users
found user: 487158
found member: 59794114
found member: 487158
found member: 191045991
(...a lot more output)

$ python data.py 487158 59794114
User 487158 :
  First name: Rick
  Last name: Pickle

User 59794114 :
  Firt name: Peter
  Username: pete
</code></pre>
<p>Telegram’s data now persists in Cassandra, and we can efficiently query it whenever we need to! I would’ve shown a video presenting its usage, but I’m afraid that would leak some of the data I want to keep private :-).</p>
<p>Feel free to download the code and try it yourself:</p>
<p><em>download removed</em></p>
<h2 id="references"><a class="anchor" href="#references">¶</a>References</h2>
<ul>
<li><a href="https://docs.datastax.com/en/developer/python-driver/3.22/getting_started/">DataStax Python Driver for Apache Cassandra – Getting Started</a></li>
<li><a href="https://docs.telethon.dev/en/latest/">Telethon’s Documentation</a></li>
</ul>
</main>
</body>
</html>
 